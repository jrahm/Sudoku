% This is "sig-alternate.tex" V2.1 April 2013
% This file should be compiled with V2.5 of "sig-alternate.cls" May 2012
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.5 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.5) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V2.0 - May 2012

\documentclass{sig-alternate-05-2015}


\begin{document}

\title{Backtracking Sudoku}
\newcommand{\sep}{\vspace{1cm}}

\numberofauthors{1} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
\alignauthor
Joshua Rahm\\
       \affaddr{University of Colorado}\\
       \email{joshua.rahm@colorado.edu}
}
\date{\today}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{abstract}
    This paper analyzes the runtime and the semantics of
    a backtracking Sudoku solver. To better undestand
    and analyze this algorithm, I have implemented
    a version of the backtracking sudoku solver in
    Haskell. This will be the base implementation from
    which the analysis will stem from.
\end{abstract}

\section{Introduction}

Sudoku is a very popular class of logic puzzles where the goal of the player is
to place numbers in cells in a grid adhering to certain constraints. The puzzle
consists of a grid, partially filled with numbers.  The grid is sized to be
$n^2\times n^2$ where $n$ is an integer. The grid is then divided up into $n$
$n\times n$ sub grids, as well as $n^2$ rows and columns. The goal of the
puzzle is to place numbers such that each row, column and sub-grid has every
number on the interval $[1, n^2]$.

For example, following is a valid solution for $n=3$ ($9\times 9$ grid)

\begin{center}
\sep
\def\arraystretch{1.5}
\begin{tabular}{| c c c | c c c | c c c |}
\hline
3&7&6&1&4&2&9&5&8 \\
5&8&4&6&7&9&2&1&3 \\
9&1&2&8&3&5&4&7&6 \\
\hline
6&9&1&2&5&4&3&8&7 \\
8&4&5&3&6&7&1&9&2 \\
2&3&7&9&1&8&5&6&4 \\
\hline
4&6&9&5&8&3&7&2&1 \\
7&2&8&4&9&1&6&3&5 \\
1&5&3&7&2&6&8&4&9 \\
\hline
\end{tabular}
\sep
\end{center}

As you can see in the example above, all boxes, rows and columns contain all
the numbers from 1 to 9.

\section{Algorithm}

The backtracking algorithm I implemented is fairly simple in concept. Sudoku is
a game where each row, column and block have a set of numbers from 1 to $n^2$
associated with that block. The first step in the algorithm is to initialize
the $SudokuPossibilities$, this is a data structure that keeps track of all
the unused numbers for each row, column and block.

\section{Analysis}

\subsection{Correctness}

The correctness of this Sudoku solving algorithm is in tow steps. % BAD!!!
First, I need to show that the solution the algorithm finds are actually correct
solutions. This means tow things. First, it means that the original hints are
in fact still in the solution! (The solver is not allowed to ignore the hints
and return just any valid board.) In addition, the board state must be valid. This
means that all rows, columns, and blocks must have unique numbers from $0..n$.

This algorithm is designed such that doing any to the contrary is impossible.

\subsection{Run Time}

\subsection{Space Usage}

\section{Pathological Cases}

\end{document}
